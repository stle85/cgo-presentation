package profiler

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
)

const (
	cpuMode = iota
	memMode
	mutexMode
	blockMode
	traceMode
	threadCreateMode
	goroutineMode
)

// profile represents an active profiling session.
type profile struct {
	// holds the type of profiling that will be made
	mode int

	// holds the base path where various profiling files are  written.
	// If blank, the base path will be generated by ioutil.TempDir.
	path string

	// holds the flag if need to generate SVG file
	genSvg bool

	// holds the rate for the memory profile.
	memProfileRate int

	// holds the profile type for memory profiles.
	// Allowed values are `heap` and `allocs`.
	memProfileType string

	// holds a cleanup function that run after each profile
	closer func()
}

// Stop stops the profile and flushes any unwritten data.
func (p *profile) Stop() {
	p.closer()
}

// MustStart starts a new profiling session.
// The caller should call the Stop method on the value returned to cleanly stop profiling.
// If something went wrong during start it raises panic.
func MustStart(options ...func(*profile)) Profile {
	p, err := Start(options...)
	if err != nil {
		panic(err.Error())
	}
	return p
}

// Start starts a new profiling session.
// The caller should call the Stop method on the value returned to cleanly stop profiling.
func Start(options ...func(*profile)) (Profile, error) {
	var prof profile
	for _, option := range options {
		option(&prof)
	}

	path, err := func() (string, error) {
		if p := prof.path; p != "" {
			return p, os.MkdirAll(p, 0o777)
		}
		return ioutil.TempDir("", "profile")
	}()
	if err != nil {
		return nil, fmt.Errorf("could not create initial output directory: %w", err)
	}

	switch prof.mode {
	case cpuMode:
		fn := filepath.Join(path, "cpu.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create cpu profile %q: %v", fn, err)
		}
		_ = pprof.StartCPUProfile(f)
		prof.closer = func() {
			pprof.StopCPUProfile()
			_ = f.Close()
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}

	case memMode:
		fn := filepath.Join(path, "mem.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create memory profile %q: %v", fn, err)
		}
		runtime.MemProfileRate = prof.memProfileRate
		prof.closer = func() {
			runtime.GC()
			_ = pprof.Lookup(prof.memProfileType).WriteTo(f, 0)
			_ = f.Close()
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}

	case mutexMode:
		fn := filepath.Join(path, "mutex.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create mutex profile %q: %v", fn, err)
		}
		runtime.SetMutexProfileFraction(1)
		prof.closer = func() {
			if mp := pprof.Lookup("mutex"); mp != nil {
				_ = mp.WriteTo(f, 0)
			}
			_ = f.Close()
			runtime.SetMutexProfileFraction(0)
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}

	case blockMode:
		fn := filepath.Join(path, "block.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create block profile %q: %v", fn, err)
		}
		runtime.SetBlockProfileRate(1)
		prof.closer = func() {
			_ = pprof.Lookup("block").WriteTo(f, 0)
			_ = f.Close()
			runtime.SetBlockProfileRate(0)
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}

	case threadCreateMode:
		fn := filepath.Join(path, "threadcreation.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create thread creation profile %q: %v", fn, err)
		}
		prof.closer = func() {
			if mp := pprof.Lookup("threadcreate"); mp != nil {
				_ = mp.WriteTo(f, 0)
			}
			_ = f.Close()
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}

	case traceMode:
		fn := filepath.Join(path, "trace.out")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create trace output file %q: %v", fn, err)
		}
		if err := trace.Start(f); err != nil {
			return nil, fmt.Errorf("could not start trace: %v", err)
		}
		prof.closer = func() {
			trace.Stop()
		}

	case goroutineMode:
		fn := filepath.Join(path, "goroutine.pprof")
		f, err := os.Create(fn)
		if err != nil {
			return nil, fmt.Errorf("could not create goroutine profile %q: %v", fn, err)
		}
		prof.closer = func() {
			if mp := pprof.Lookup("goroutine"); mp != nil {
				_ = mp.WriteTo(f, 0)
			}
			_ = f.Close()
			if prof.genSvg {
				_ = convertToSvg(fn)
			}
		}
	}

	return &prof, nil
}
